% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster.R
\name{cluster_segments}
\alias{cluster_segments}
\title{Cluster segments of a ctdf}
\usage{
cluster_segments(ctdf, nmin = 3, threshold = 2, time_contiguity = FALSE)
}
\arguments{
\item{ctdf}{A `ctdf` object, must contain a `.segment` column; see [slice_ctdf()],.}

\item{nmin}{Integer. Segments or tessellations with fewer than nmin points yield no clusters.
Default to 3.}

\item{threshold}{Numeric. The multiplier of the standard deviation on log‐areas used in pruning.}

\item{time_contiguity}{Logical; if `TRUE`, missing cluster IDs are forward‐filled
and backward‐filled within each segment to enforce temporal continuity. Default to `FALSE`.}

\item{progress_bar}{Logical; whether to display a progress bar during execution. Defaults to `TRUE`.}
}
\value{
Invisibly returns `NULL`. The input `ctdf` is modified by reference,
 updating the column `cluster`; `0` indicates unclustered points.
}
\description{
Compute cluster IDs for each point in a `ctdf` by segment, using Dirichlet
tessellation followed by area-based pruning, spatial adjacency and graph-based clustering.
Optionally enforce temporal contiguity of clusters within each segment.
}
\details{
For each unique segment in `ctdf`, points are tessellated via
  [tessellate_ctdf()], pruned via [prune_tesselation()], and adjacency
  neighborhoods are computed with `poly2nb()`. These neighborhoods are
  converted to an undirected graph, and clusters are identified as connected
  components.
}
\examples{
data(toy_ctdf_k3)
ctdf = as_ctdf(toy_ctdf_k3)
slice_ctdf(ctdf)
tessellate_ctdf(ctdf )
cluster_segments(ctdf)

  x = ctdf[.segment == 6]
ggplot()+geom_sf(data=x[, .(keep, tesselation)]|>st_as_sf(), aes(color = keep))
tinyplot(~ix|keep, data=x, type = type_histogram(breaks = 30))
}
